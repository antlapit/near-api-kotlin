package org.near.api.model.transaction

import org.near.api.model.block.Receipt
import org.near.api.model.primitives.*

open class FinalExecutionOutcome(
    /// Execution status. Contains the result in case of successful execution.
    open val status: FinalExecutionStatus,
    /// Signed Transaction
    open val transaction: SignedTransactionView,
    /// The execution outcome of the signed transaction.
    open val transactionOutcome: ExecutionOutcomeWithIdView,
    /// The execution outcome of receipts.
    open val receiptsOutcome: List<ExecutionOutcomeWithIdView> = emptyList(),
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as FinalExecutionOutcome

        if (status != other.status) return false
        if (transaction != other.transaction) return false
        if (transactionOutcome != other.transactionOutcome) return false
        if (receiptsOutcome != other.receiptsOutcome) return false

        return true
    }

    override fun hashCode(): Int {
        var result = status.hashCode()
        result = 31 * result + transaction.hashCode()
        result = 31 * result + transactionOutcome.hashCode()
        result = 31 * result + receiptsOutcome.hashCode()
        return result
    }

    override fun toString(): String {
        return "FinalExecutionOutcome(status=$status, transaction=$transaction, transactionOutcome=$transactionOutcome, receiptsOutcome=$receiptsOutcome)"
    }

}

data class FinalExecutionOutcomeWithReceipts(
    /// Execution status. Contains the result in case of successful execution.
    override val status: FinalExecutionStatus,
    /// Signed Transaction
    override val transaction: SignedTransactionView,
    /// The execution outcome of the signed transaction.
    override val transactionOutcome: ExecutionOutcomeWithIdView,
    /// The execution outcome of receipts.
    override val receiptsOutcome: List<ExecutionOutcomeWithIdView> = emptyList(),

    val receipts: List<Receipt> = emptyList()
) : FinalExecutionOutcome(status, transaction, transactionOutcome, receiptsOutcome)

data class ExecutionOutcomeWithIdView(
    val proof: MerklePath,
    val blockHash: CryptoHash,
    val id: CryptoHash,
    val outcome: ExecutionOutcomeView
)

data class ExecutionOutcomeView(
    /// Logs from this transaction or receipt.
    val logs: List<String> = emptyList(),
    /// Receipt IDs generated by this transaction or receipt.
    val receiptIds: List<CryptoHash> = emptyList(),
    /// The amount of the gas burnt by the given transaction or receipt.
    val gasBurnt: Gas,
    /// The amount of tokens burnt corresponding to the burnt gas amount.
    /// This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
    /// the prepaid gas price might be lower than the actual gas price and it creates a deficit.
    val tokensBurnt: Balance,
    /// The id of the account on which the execution happens. For transaction this is signerId,
    /// for receipt this is receiverId.
    val executorId: AccountId,
    /// Execution status. Contains the result in case of successful execution.
    val status: ExecutionStatus,
    /// Execution metadata, versioned
    val metadata: ExecutionMetadataView
)


data class MerklePathItem(
    val hash: MerkleHash,
    val direction: Direction,
)

typealias MerklePath = List<MerklePathItem>

enum class Direction {
    Left,
    Right
}

data class CostGasUsed(
    val costCategory: String,
    val cost: String,
    val gasUsed: Gas,
)

data class ExecutionMetadataView(
    val version: Int,
    val gasProfile: List<CostGasUsed>?
)
